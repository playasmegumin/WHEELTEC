# 基于WHEELTEC B570 平衡小车的嵌入式作业代码

本项目基于 “WHEELTEC B570 平衡小车源码（HAL库版-STM32CubeIDE）” 开发而来。

### 2024.5.8 更新

#### 更新内容

1. 完善了Job模式，现在它既可以按照预设指令队列运行，也可以按照遥控app输入的指令队列运行
   - 在Job模式下，OLED屏幕中的Angle数值会变成Pointer（job_pointer），可以通过观察Pointer判断小车正在运行指令队列的哪一个行动
   - 指令队列的数据结构为job_list[60]，其中0~19为预设指令队列，20~59为用户输入指令队列（即运行用户指令队列时，Pointer会从20开始）
   - 用户输入指令队列的第一个行动固定为“停止”，用户输入的第一个行动会在Pointer等于22时进行
   - 用户输入指令队列的行动总是 “用户输入行动”+“停止”，例如，当用户输入的前两个行动为 “前进”和“左转” 时，job_list[20] == 停止，job_list[21] == 停止，job_list[22] == 前进，job_list[23] == 停止，job_list[24] == 左转，job_list[25] == 停止。可以结合Pointer的数值观察这一机制。
2. 修改了遥控模块(usart3.c)：
   - 增加了用于控制Job模式三种行动时长参数的“参数设置条”
   - 增加了令小车一键躺倒的按键（躺倒！）
   - 增加了指令队列运行控制的相关按键逻辑，包括：清空、从头启动、暂停、取消暂停
     - 使用“清空”后，Pointer应为20，随后停在21，这两个行动都是“停止”
     - 使用“从头启动”后，Pointer应为20，并开始往后执行直到59
     - 使用“暂停”后，Pointer应停在当前行动后的第一个奇数，如Pointer当前为22，那么它应该在23停止
     - 使用“取消暂停”后，Pointer应该会继续运行（但我并没有测试这一逻辑，测了跟我说一声谢谢你）
   - 增加了向当前指令队列尾部增加新行动的按键逻辑：停止、前进、左转、右转等四种行动
     - 最多可输入18个行动，之后输入的行动会覆盖最后一个行动（我没有测试这个逻辑，如果爆了就断电重启，建议不要超过15个行动）
     - “行动：停止”，“行动：前进”，“行动：左转”，“行动：右转”等按键会向当前已有的用户输入指令队列尾部增加新的行动（已测试能用，不能用就重启）
   - 需要按照截图手动设置遥控app的操控界面（无法通过“获取设备参数”获得小车程序中新增加的三个参数数值，需要手动调整一下）
   - 另，每次重新用蓝牙连接小车似乎都会重新发送所有参数，包括按键输入历史，警惕因为这一点产生的令人困惑的问题（未验证，证实的话说一声）
3. 相关数据结构说明：
   - job_list[60]：这个数组很重要！Job模式下的指令队列，其中0~19被划分给预设的默认队列，可以在job_list的定义处找到相关内容；20~59被划分给用户输入指令队列。数值只可能是0、1、2、3、4，分别代表停止、前进、左转、右转以及暂停。4的作用机制和前面四种不一样（体现在control.c的流程控制逻辑中），因此job_dir中只有0123四种。
   - job_action：这个数据结构不需要特别关注。Job模式下用于指示当前正在进行的行动，即job_action = job_list[job_pointer]。可能取0、1、2、3、4四个数值。当job_action==4时小车会暂停执行指令队列，但仅可能出现在Pointer > 20（当前处于用户输入指令队列）的情况下。（注意，“取消暂停”逻辑仅对Pointer>20有效）
   - job_dir\[4\]\[3\]：这个数据结构不需要特别关注。Job模式下四种行动的数据结构，其中第三个元素指的是该行动的持续时长（200等于1秒），这个数据结构不需要特别关注。
   - job_counter：这个数据结构不需要特别关注。Job模式下用于计时的变量，数值范围是0~job_dir\[job_action\]\[2\]。如设定左转右转的持续时长为150的话，当job_counter从0增加到150时即认为当前转向行动已完成。
   - job_pointer：这个变量很重要！Job模式下用于指示当前处于指令队列中的哪一个元素的指针（就是下标），此时此刻小车总是在执行job_list[job_pointer]所指示的行动。
   - job_usart_pointer：这个变量一般重要。Job模式下用于指示当前用户输入指令队列队尾所在之处的指针（也是下标），当用户输入新的行动指令时，总是会被置入job_list[job_usart_pointer]中。
   - sin100[0]：这个变量很重要！这个元素是目前小车的目标速度，之所以显得如此粗糙是因为在实现Swing模式的过程中修改了Velocity函数的控制逻辑，导致所有模式下的默认目标速度都变成了sin100[0]。如果不理解这一点的话，可能会感到困惑。

为了让读者基本了解本次更新的内容，这里提供了一个上手流程。

#### 上手流程

1. 提前清理1平方米左右的地面（扫扫就行，越干净越好），用湿巾稍微擦擦小车车轮，这对效果的影响很大！
2. 打开蓝牙遥控app，将相关按键名称修改得和截图一样；将相关参数条名称和数值范围和起始值也修改得和截图一样（截图在哪？下次再发github好了）
3. 启动小车，先不连接蓝牙，先旋转右车轮使OLED屏幕中的”模式“行变成Swing，此时”Angle“会变成”Sin“。这是摇摆模式，小车将重复前后摆动。Sin会指示小车的目标速度在一整个sin周期中所处的位置（0~100为一个完整周期）
4. 将小车放到地上，按下启动键，小车将开始前后往复摆动（按下启动键将改变Flag_Stop的数值，0变1或1变0），Sin会由0变100再从0变100。
5. 用手固定小车，按下启动键，小车会停止运作且不保持平衡。（Flag_Stop = 0）
6. 转动右车轮，直到”模式“行变成Job，此时”Angle“会变成”Pointer“。这是指令队列模式，小车将按照一定的顺序执行指令。Pointer会指示小车当前正在执行的是第几个行动（对应job_list数组当前的下标，即job_pointer）。
7. 将小车放到地上，按下启动键。Pointer为0~2时会保持原地平衡，随后前进、左转、前进、左转、前进、左转、前进，随后停止。小车会走出一个矩形的路径，天气好的话应该是正方形。最后，Pointer会在数值19停下来，代表已经结束预置指令队列的运行。
8. 不需要再按下启动键，可以在小车处于平衡状态时直接进行后面的步骤
9. 用蓝牙遥控app连接小车，转到”调试“标签页，用右上角的菜单”获取设备参数“（当然，不做也没有问题）
10. 按下”清空“按键，小车会进入用户输入指令队列，Pointer会先变成20，然后停在21。此时小车不会产生任何运动，会原地保持平衡。
11. 依次按下”行动：左转“、”行动：右转“、”行动：左转“、”行动：右转“、”行动：前进“，在”首页“标签页的debug指示框可以看到app发送了gigih。小车此时会接收到指令，但不会作出行动。
12. 按下”从头开始“，Pointer会从20开始增长，到22时进行第一个行动”左转“。结束行动后，Pointer仍会增长直到59，但后面默认均为”停止“指令，小车不会再有任何有意义的行动。
13. 小车结束行动后，再次按下”从头开始“，并在小车行动的过程中按下”行动暂停“，小车会停止运行指令队列，原地保持平衡。按下“取消暂停”，小车会继续执行（它应该会，但我没测）
14. 用手保护小车，按下“躺倒！”，小车会直接躺倒，效果等同于按下启动键。（启动键是小车电路板上自带的那个按钮）
15. 如果小车仍是Job模式，再次按下启动键时Pointer将置0，仍从预设队列开始。但可以随时按下“清空”按钮和”从头开始”按钮令其进入用户输入指令队列（Pointer变为20），注意，这里的核心是Pointer。Job模式小车将执行什么行动，运行状态如何，都可以通过Pointer进行判断。
16. 你总是能观察到，当Pointer为奇数时小车会执行”停止“行动。

#### 开发建议

如果你需要修改相关逻辑，你应该关注这些文件：

1. WHEELTEC/control.c：包含主要的控制逻辑，包括Job模式的主要流程控制。如果你想要修改Job模式中加速和减速的方式，可以关注这里。
2. BSPcode/usart3.c：包含蓝牙遥控输入的信号解读逻辑。如果你想要增加新的按钮或者修改数据解读会给小车参数带来的影响，可以关注这里。（有GUA的地方就是我修改过的）
3. WHEELTEC/show.c：包含OLED屏幕的显示逻辑。如果你想要修改OLED屏幕上展示的信息，可以关注这里。另，这里的代码很好理解，但是排版依托答辩。

代码中包含的注释希望可以更进一步帮助你。

### 2024.5.7 更新：改进Job模式

更新内容：

1. 搞定了OLED显示屏在不同模式下的显示问题，比如在Normal模式下现在又可以看到Angle了。

2. 在蓝牙遥控app上增加了Job模式前进、左转、右转持续时长的快速调参，现在它们分别是参数6、7、8。200对应1秒。

3. 考虑加入单步遥控功能。

4. 考虑让小车在Job模式下结束指令队列后恢复平衡状态而不是Stop（倒下）。

### 2024.5.5 更新：增加了Job模式，在git中新增Job分支

通过修改sin100[0]的数值控制速度，通过修改Flag_Left和Flag_Right控制转动。

调试时需注意重置是否有效，至于蓝牙控制要是影响了就影响了吧。

2024.4.4更新：增加了Swing模式，但这部分修改仍处于Swing分支上。

## 最高注意事项

我所有的注释都是在utf-8编码下写的。如果出现乱码请更改文件编码为utf-8，同时避免在GTK编码下保存文件，否则会产生不可逆的注释丢失。

## 值得关注的文件和函数

### WHEELTEC/control.c

这是小车控制流程的主文件，其中的HAL_GPIO_EXTI_Callback是包含了小车控制主要逻辑的函数。

Core/main.c里面曾经提到过：由于delay的精度差强人意，本项目采用mpu6050自带的时间中断构成delay50（可以开摆50ms）。

本项目的主要驱动方式是每5ms接收来自mpu6050的中断请求，然后利用HAL_GPIO_EXTI_Callback回调函数进行主逻辑的处理。

这个函数就是个小小的状态机。

标识模式的核心变量是Flag_avoid和Flag_follow。如果Flag_avoid==1就是避障模式，如果Flag_follow==1就是跟随模式。因此在这里我加了一个Flag_swing表示摇摆模式。

此外，我还添加了sin100[]数组和sin100_counter。前者是我用matlab得到的100个采样点的sin函数，后者是一个全局变量，标示小车在此时此刻所处的相位（差不多这个意思）。根据相位可以得到此时小车应有的目标速度。只要速度是三角函数，位移也将是三角函数，借此实现小车的摇摆。

### WHEELTEC/show.c

这是用于设计OLED屏幕的文件。

我修改了里面的部分内容以在OLED上显示sin100[]当前的数值。

### Core/Inc/main.h

我在里面添加了相关的变量声明以令上述行为生效。